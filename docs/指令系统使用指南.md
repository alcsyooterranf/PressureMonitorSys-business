# 指令系统完整使用指南

## 一、系统架构

### 1.1 核心组件

| 组件 | 职责 | 位置 |
|------|------|------|
| **CommandController** | HTTP接口层 | `business-trigger` |
| **CommandTaskService** | 指令任务业务逻辑 | `business-domain` |
| **AepCommandClient** | AEP SDK封装 | `business-domain` |
| **CommandFacade** | RPC接口（接收回调） | `business-trigger` |
| **CommandRespHandler** | 指令响应处理 | `business-application` |
| **StateHandler** | 状态机流转 | `business-domain` |

### 1.2 状态流转图

```
INITIALIZED (已初始化)
    ↓
SAVED (已保存) ← AEP平台保存成功
    ↓
SENT (已发送) ← AEP平台发送到设备
    ↓
DELIVERED (已送达) ← 设备收到指令
    ↓
COMPLETED (已完成) ← 设备执行完成

特殊状态:
- TTL_TIMEOUT: 指令TTL超时（未在有效期内送达）
- TIMEOUT: 指令执行超时（送达但未完成）
```

## 二、完整使用流程

### 步骤1: 创建指令任务

**接口**: `POST /command/task/create`

**请求示例**:
```json
{
  "pipelineId": 17087544,
  "serviceIdentifier": "test_command",
  "args": "{\"syn\":\"tongbu\",\"test_attr\":11}",
  "tenantId": "tenant_001"
}
```

**响应示例**:
```json
{
  "code": "SUCCESS",
  "message": "成功",
  "data": 1
}
```

**说明**:
- `pipelineId`: 管道ID（对应AEP的productId）
- `serviceIdentifier`: 服务标识符（必须在指令元数据中已定义）
- `args`: 指令参数（JSON字符串，会根据payload_schema进行校验）
- 返回的`data`是`taskId`，用于后续下发指令

---

### 步骤2: 下发指令

#### 2.1 同步下发

**接口**: `POST /command/task/send`

**请求示例**:
```json
{
  "taskId": 1,
  "deviceId": 1,
  "deviceSN": 1708754401,
  "pipelineId": 17087544
}
```

**响应示例**:
```json
{
  "code": "SUCCESS",
  "message": "成功",
  "data": 64
}
```

**说明**:
- 返回的`data`是`aepTaskId`（AEP平台的commandId）
- 同步等待AEP平台响应，适合需要立即知道下发结果的场景

#### 2.2 异步下发

**接口**: `POST /command/task/send/async`

**请求示例**:
```json
{
  "taskId": 1,
  "deviceId": 1,
  "deviceSN": 1708754401,
  "pipelineId": 17087544
}
```

**响应示例**:
```json
{
  "code": "SUCCESS",
  "message": "指令已提交，正在后台执行",
  "data": null
}
```

**说明**:
- 立即返回，不等待AEP平台响应
- 适合批量下发或对响应时间要求不高的场景

---

### 步骤3: 接收指令响应（状态流转）

**这是关键步骤！** 当设备执行指令后，AEP平台会通过回调通知网关，网关再通过RPC调用后端服务。

#### 3.1 RPC接口

**接口**: `POST /api/device/command/save`

**请求示例** (由网关发送):
```json
{
  "deviceId": "1708754401",
  "pipelineId": "17087544",
  "taskId": 64,
  "commandState": "DELIVERED",
  "commandResult": {
    "status": "success",
    "data": {
      "result": "ok"
    }
  },
  "timestamp": 1734567890000,
  "tenantId": "tenant_001"
}
```

**commandState枚举值**:
- `SAVED`: 指令已保存到AEP平台
- `SENT`: 指令已发送到设备
- `DELIVERED`: 设备已收到指令
- `COMPLETED`: 设备已执行完成
- `TTL_TIMEOUT`: 指令TTL超时
- `TIMEOUT`: 指令执行超时

---

## 三、状态流转规则

### 3.1 允许的状态流转

| 当前状态 | 可流转到 | 说明 |
|---------|---------|------|
| INITIALIZED | SAVED, SENT | 初始化后可保存或直接发送 |
| SAVED | SENT | 保存后发送到设备 |
| SENT | DELIVERED, TIMEOUT | 发送后等待送达或超时 |
| DELIVERED | COMPLETED | 送达后等待执行完成 |
| COMPLETED | - | 终态，不可流转 |
| TTL_TIMEOUT | - | 终态，不可流转 |
| TIMEOUT | - | 终态，不可流转 |

### 3.2 非法流转示例

```
INITIALIZED -> COMPLETED ❌ (不允许跳过中间状态)
SAVED -> COMPLETED ❌ (必须先SENT -> DELIVERED)
COMPLETED -> SENT ❌ (终态不可流转)
```

---

## 四、数据库表结构

### 4.1 t_command_task (指令任务表)

存储指令任务的基本信息，一个任务可以多次下发给不同设备。

### 4.2 t_command_execution (指令执行记录表)

存储每次指令下发的执行记录，包含状态流转信息。

**关键字段**:
- `aep_task_id`: AEP平台返回的commandId
- `device_id`: 设备ID
- `status`: 当前状态
- `last_raw_callback`: 最后一次回调的原始JSON
- `result_detail`: 执行结果详情
- `last_callback_time`: 最后回调时间

---

## 五、常见问题

### Q1: 如何知道指令是否执行成功？

**A**: 查询`t_command_execution`表，根据`aep_task_id`和`device_id`查询：
- `status = 5 (COMPLETED)` 表示执行成功
- `status = 7 (TIMEOUT)` 表示执行超时
- 查看`result_detail`字段获取详细结果

### Q2: 指令下发后多久会有响应？

**A**: 取决于设备的在线状态和网络情况：
- 设备在线：通常1-5秒内收到DELIVERED状态
- 设备离线：等待设备上线，可能需要几分钟到几小时
- TTL超时：默认7200秒（2小时），超时后状态变为TTL_TIMEOUT

### Q3: 如何处理指令下发失败？

**A**: 
1. 检查`external_error_msg`字段获取错误信息
2. 根据错误类型决定是否重试
3. 可以使用相同的`taskId`重新下发

### Q4: 状态流转失败怎么办？

**A**: 
- 检查日志，查看具体的异常信息
- 确认状态流转是否合法（参考状态流转规则）
- 检查数据库中的当前状态是否正确

---

## 六、最佳实践

### 6.1 指令下发

1. **优先使用异步下发**: 批量下发时使用异步接口，提高吞吐量
2. **设置合理的TTL**: 根据业务场景设置指令有效期
3. **记录taskId**: 保存taskId用于后续查询和重试

### 6.2 状态监控

1. **定时轮询**: 对于重要指令，定时查询执行状态
2. **超时处理**: 设置业务超时时间，超时后进行告警或重试
3. **日志记录**: 记录每次状态流转的时间和结果

### 6.3 异常处理

1. **幂等性**: 确保重复下发相同指令不会产生副作用
2. **重试机制**: 对于临时性错误，实现指数退避重试
3. **告警通知**: 对于关键指令失败，及时通知相关人员

---

## 七、完整代码示例

### 7.1 指令下发完整流程

```java
// 1. 创建指令任务
CreateCommandTaskReq createReq = CreateCommandTaskReq.builder()
    .pipelineId(17087544L)
    .serviceIdentifier("test_command")
    .args("{\"syn\":\"tongbu\",\"test_attr\":11}")
    .tenantId("tenant_001")
    .build();

Response<Long> createResp = commandController.createCommandTask(createReq);
Long taskId = createResp.getData();  // 获取任务ID

// 2. 下发指令（异步）
SendCommandReq sendReq = SendCommandReq.builder()
    .taskId(taskId)
    .deviceId(1L)
    .deviceSN(1708754401L)
    .pipelineId(17087544L)
    .build();

commandController.sendCommandAsync(sendReq);

// 3. 轮询查询执行状态（可选）
// 注意：实际项目中应该通过回调或消息队列获取状态，而不是轮询
```

### 7.2 网关回调处理流程

当设备执行指令后，完整的调用链路如下：

```
设备 → AEP平台 → 网关 → CommandFacade.handleCommandResp()
    → CommandRespHandler.handleCommandResponse()
    → StateHandler.delivered/completed/timeout()
    → 更新数据库状态
```

**网关调用示例**:
```java
// 网关收到AEP回调后，构造CommandResponseDTO并调用RPC接口
CommandResponseDTO dto = CommandResponseDTO.builder()
    .deviceId("1708754401")
    .pipelineId("17087544")
    .taskId(64L)
    .commandState(CommandState.DELIVERED)
    .commandResult(commandResultJson)
    .timestamp(System.currentTimeMillis())
    .tenantId("tenant_001")
    .build();

// 调用后端RPC接口
Response<Boolean> response = commandFacade.handleCommandResp(dto);
```

**后端处理流程**:
```java
// CommandFacade接收RPC请求
public Response<Boolean> handleCommandResp(CommandResponseDTO commandResponse) {
    // 调用CommandRespHandler处理
    commandRespHandler.handleCommandResponse(
        commandResponse.getTaskId(),
        Long.parseLong(commandResponse.getDeviceId()),
        commandResponse.getCommandState(),
        commandResponse.getCommandResult(),
        commandResponse.toString()
    );
    return Response.success(true);
}

// CommandRespHandler处理指令响应
public void handleCommandResponse(Long aepTaskId, Long deviceId,
                                   CommandState commandState,
                                   JsonNode commandResult,
                                   String rawCallback) {
    // 1. 查询当前执行记录
    CommandExecutionEntity execution =
        commandExecutionRepository.selectByAepTaskIdAndDeviceId(aepTaskId, deviceId);

    // 2. 更新执行结果
    commandExecutionRepository.updateResult(aepTaskId, deviceId,
        commandResult.toString(), rawCallback);

    // 3. 触发状态流转
    switch (commandState) {
        case DELIVERED:
            stateHandler.delivered(aepTaskId, deviceId, execution.getStatus());
            break;
        case COMPLETED:
            stateHandler.completed(aepTaskId, deviceId, execution.getStatus());
            break;
        // ... 其他状态
    }
}
```

### 7.3 状态流转示例

```java
// 状态机会自动验证流转是否合法
// 例如：SENT -> DELIVERED
@Override
public void delivered(Long aepTaskId, Long deviceId, CommandExecutionStatusVO currentState) {
    // 验证当前状态是否允许流转到DELIVERED
    if (currentState != CommandExecutionStatusVO.SENT) {
        throw new BizException(BusinessErrorCode.COMMAND_STATE_ILLEGAL_TRANSITION,
            "非法状态流转: " + currentState + " -> DELIVERED");
    }

    // 更新状态
    commandExecutionRepository.updateStatus(aepTaskId, deviceId,
        CommandExecutionStatusVO.DELIVERED);
}
```

---

## 八、架构图

### 8.1 完整调用链路

```
┌─────────────┐
│   前端/API  │
└──────┬──────┘
       │ 1. 创建任务
       │ 2. 下发指令
       ▼
┌─────────────────┐
│CommandController│ (HTTP接口)
└────────┬────────┘
         │
         ▼
┌──────────────────┐
│CommandTaskService│ (业务逻辑)
└────────┬─────────┘
         │
         ▼
┌─────────────────┐
│ AepCommandClient│ (SDK封装)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   AEP平台       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   IoT设备       │
└────────┬────────┘
         │ 执行完成
         ▼
┌─────────────────┐
│   AEP平台       │ (回调)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│     网关        │ (RPC调用)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ CommandFacade   │ (RPC接口)
└────────┬────────┘
         │
         ▼
┌──────────────────────┐
│ CommandRespHandler   │ (应用层服务)
└────────┬─────────────┘
         │
         ▼
┌─────────────────┐
│  StateHandler   │ (状态机)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   MySQL数据库   │
└─────────────────┘
```

---

## 九、总结

指令系统的核心要点：

1. **创建任务** → 调用`/command/task/create`接口
2. **下发指令** → 调用`/command/task/send`或`/command/task/send-async`接口
3. **接收响应** → 网关通过RPC调用`/api/device/command/save`接口
4. **状态流转** → `CommandRespHandler`自动触发状态机流转
5. **查询结果** → 查询`t_command_execution`表获取执行状态

**关键点**：
- 状态流转由`CommandRespHandler`和`StateHandler`自动处理
- 网关负责接收AEP回调并转发给后端
- 所有状态流转都有严格的规则验证
- 异常情况会抛出`BizException`并记录日志

